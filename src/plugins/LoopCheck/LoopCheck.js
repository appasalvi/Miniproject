/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Aug 08 2025 03:52:23 GMT+0000 (Coordinated Universal Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
  "plugin/PluginConfig",
  "text!./metadata.json",
  "plugin/PluginBase",
], function (PluginConfig, pluginMetadata, PluginBase) {
  "use strict";

  pluginMetadata = JSON.parse(pluginMetadata);

  /**
   * Initializes a new instance of LoopCheck.
   * @class
   * @augments {PluginBase}
   * @classdesc This class represents the plugin LoopCheck.
   * @constructor
   */
  function LoopCheck() {
    // Call base class' constructor.
    PluginBase.call(this);
    this.pluginMetadata = pluginMetadata;
  }

  /**
   * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
   * This is also available at the instance at this.pluginMetadata.
   * @type {object}
   */
  LoopCheck.metadata = pluginMetadata;

  // Prototypical inheritance from PluginBase.
  LoopCheck.prototype = Object.create(PluginBase.prototype);
  LoopCheck.prototype.constructor = LoopCheck;

  /**
   * Main function for the plugin to execute. This will perform the execution.
   * Notes:
   * - Always log with the provided logger.[error,warning,info,debug].
   * - Do NOT put any user interaction logic UI, etc. inside this method.
   * - callback always has to be called even if error happened.
   *
   * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
   */
  LoopCheck.prototype.main = function (callback) {
    // Use this to access core, project, result, logger etc from PluginBase.
    var self = this;
    var activeNode = this.activeNode,
      core = this.core,
      logger = this.logger;
    logger.debug("path:", core.getPath(activeNode));
    logger.info("name:", core.getAttribute(activeNode, "name"));
    logger.warn("pos :", core.getRegistry(activeNode, "position"));
    logger.error("guid:", core.getGuid(activeNode));
    logger.info("Starting cycle detection...");

    // Load all nodes in the subtree first
    this.loadNodeMap(activeNode)
      .then(function (nodes) {
        // Function to detect cycles using loaded nodes
        function detectCycles(programNode) {
          var visited = {};
          var currentPath = {};
          var cycleElements = [];

          // Get all children paths
          var children = core.getChildrenPaths(programNode);

          // Check for cycles in command sequence
          for (var i = 0; i < children.length; i++) {
            var childPath = children[i];
            var childNode = nodes[childPath]; // Access from loaded nodes map

            if (!childNode) {
              logger.warn("Node not found in loaded map: " + childPath);
              continue;
            }

            var metaType = core.getAttribute(
              core.getMetaType(childNode),
              "name",
            );
            logger.info("name:", core.getAttribute(childNode, "name"));
            logger.info("pos :", core.getRegistry(childNode, "position"));
            logger.info("guid:", core.getGuid(childNode));
            // Rest of cycle detection logic...
            if (currentPath[childPath]) {
              cycleElements = Object.keys(currentPath).concat([childPath]);
              return {
                found: true,
                elements: cycleElements.map(function (path) {
                  var node = nodes[path];
                  return (
                    core.getAttribute(node, "name") ||
                    core.getAttribute(core.getMetaType(node), "name")
                  );
                }),
              };
            }
            currentPath[childPath] = true;
          }
          // If it's a function, check for recursive calls
          if (metaType === "Function") {
            var funcChildren = core.getChildrenPaths(childNode);
            for (var j = 0; j < funcChildren.length; j++) {
              var funcChildPath = funcChildren[j];
              if (currentPath[funcChildPath]) {
                cycleElements = Object.keys(currentPath).concat([
                  funcChildPath,
                ]);
                return {
                  found: true,
                  elements: cycleElements.map(function (path) {
                    var node = nodes[path];
                    return (
                      core.getAttribute(node, "name") ||
                      core.getAttribute(core.getMetaType(node), "name")
                    );
                  }),
                };
              }
            }
          }
          return { found: false, elements: [] };
        }

        // Run cycle detection with loaded nodes
        var result = detectCycles(activeNode);

        if (result.found) {
          logger.error(
            "Cycle detected! Sequential code generation is not safe.",
          );
          logger.error("Elements in cycle: " + result.elements.join(" -> "));
        } else {
          logger.info(
            "No cycles detected. Sequential code generation is safe.",
          );
          // result.setSuccess(true);
        }

        callback(null, self.result);
      })
      .catch(function (err) {
        logger.error("Error loading nodes: " + err.message);
        callback(err);
      });
  };

  return LoopCheck;
});
